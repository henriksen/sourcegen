using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Generators;

[Generator]
public sealed class StrongIdGenerator : IIncrementalGenerator
{
    private const string AttrFqn = "Annotations.StrongIdAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // Discover partial structs annotated with [StrongId]
        var candidates = ctx.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: AttrFqn,
            predicate: static (node, _) => node is StructDeclarationSyntax s && s.Modifiers.Any(m => m.Text == "partial"),
            transform: static (syntaxCtx, _) =>
            {
                var symbol = (INamedTypeSymbol)syntaxCtx.TargetSymbol;
                var attr = syntaxCtx.Attributes[0];

                var underlyingArg = attr.ConstructorArguments.Length == 1
                    ? (attr.ConstructorArguments[0].Value?.ToString() ?? "System.Guid")
                    : "System.Guid";

                return new StrongIdModel(
                    ns: symbol.ContainingNamespace.IsGlobalNamespace ? null : symbol.ContainingNamespace.ToDisplayString(),
                    name: symbol.Name,
                    accessibility: symbol.DeclaredAccessibility,
                    underlyingTypeDisplay: underlyingArg
                );
            });

        // Use a custom comparer (no System.HashCode) so incremental semantics are stable
        var models = candidates.WithComparer(StrongIdModelEqualityComparer.Instance).Collect();

        ctx.RegisterSourceOutput(models, static (spc, batch) =>
        {
            foreach (var model in batch)
            {
                spc.AddSource($"{model.Name}.StrongId.g.cs", Emit(model));
            }
        });
    }

    private static string Emit(StrongIdModel m)
    {
        var ns = m.Namespace is null ? null : $"namespace {m.Namespace};";
        var acc = m.Accessibility.ToString().ToLowerInvariant();
        var t = m.UnderlyingTypeDisplay;

        // detect special-cases
        bool isGuid = string.Equals(t, "System.Guid", StringComparison.Ordinal) || string.Equals(t, "Guid", StringComparison.Ordinal);
        bool isString = string.Equals(t, "System.String", StringComparison.Ordinal) || string.Equals(t, "string", StringComparison.Ordinal);

        string toStringBody = isString ? "_value ?? string.Empty" : "_value.ToString()";
        string getHashBody = isString
            ? "(_value == null ? 0 : _value.GetHashCode())"
            : $"System.Collections.Generic.EqualityComparer<{t}>.Default.GetHashCode(_value)";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        if (ns is not null) sb.AppendLine(ns).AppendLine();

        sb.AppendLine(
            $$"""
            {{acc}} readonly partial struct {{m.Name}} : System.IEquatable<{{m.Name}}>
            {
                private readonly {{t}} _value;
                public {{m.Name}}({{t}} value) => _value = value;
            
                public static implicit operator {{t}}({{m.Name}} id) => id._value;
                public static explicit operator {{m.Name}}({{t}} value) => new(value);
            
                public bool Equals({{m.Name}} other) => System.Collections.Generic.EqualityComparer<{{t}}>.Default.Equals(_value, other._value);
                public override bool Equals(object? obj) => obj is {{m.Name}} other && Equals(other);
                public override int GetHashCode() => {{getHashBody}};
                public override string ToString() => {{toStringBody}};
            """);

        if (isGuid)
        {
            sb.AppendLine(
                $$"""
                            
                    public static {{m.Name}} New() => new(System.Guid.NewGuid());
                
                    public static bool TryParse(string? s, out {{m.Name}} value)
                    {
                        var ok = System.Guid.TryParse(s, out var g);
                        value = ok ? new(g) : default;
                        return ok;
                    }
                """);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private sealed class StrongIdModel(
        string? ns,
        string name,
        Accessibility accessibility,
        string underlyingTypeDisplay)
    {
        public string? Namespace { get; } = ns;
        public string Name { get; } = name;
        public Accessibility Accessibility { get; } = accessibility;
        public string UnderlyingTypeDisplay { get; } = underlyingTypeDisplay;
    }

    private sealed class StrongIdModelEqualityComparer : IEqualityComparer<StrongIdModel>
    {
        public static readonly StrongIdModelEqualityComparer Instance = new();

        public bool Equals(StrongIdModel? x, StrongIdModel? y)
        {
            if (ReferenceEquals(x, y)) return true;
            if (x is null || y is null) return false;
        
            return string.Equals(x.Namespace, y.Namespace, StringComparison.Ordinal)
                   && string.Equals(x.Name, y.Name, StringComparison.Ordinal)
                   && string.Equals(x.UnderlyingTypeDisplay, y.UnderlyingTypeDisplay, StringComparison.Ordinal)
                   && x.Accessibility == y.Accessibility;
        }

        public int GetHashCode(StrongIdModel obj)
        {
            return (obj.Namespace, obj.Name, obj.UnderlyingTypeDisplay, obj.Accessibility).GetHashCode();
        }
    }
}
