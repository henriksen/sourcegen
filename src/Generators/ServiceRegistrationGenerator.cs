using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Generators;

[Generator]
public sealed class ServiceRegistrationGenerator : IIncrementalGenerator
{
    private const string AttrFqn = "Annotations.ServiceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // 1) Find candidate class declarations that have attributes (syntax-only, fast)
        var classSyntax = ctx.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) =>
                node is ClassDeclarationSyntax c &&
                c.AttributeLists.Count > 0 &&
                c.TypeParameterList is null, // skip generics for simplicity
            transform: static (syntaxCtx, _) =>
            {
                var classDecl = (ClassDeclarationSyntax)syntaxCtx.Node;
                var symbol = syntaxCtx.SemanticModel.GetDeclaredSymbol(classDecl);
                return symbol;
            })
            .Where(static s => s is not null)!;

        // 2) Keep only classes actually annotated with [Annotations.ServiceAttribute]
        var services = classSyntax
            .Select(static (sym, _) =>
            {
                var attr = sym!.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttrFqn);
                return (sym, attr);
            })
            .Where(static t => t.attr is not null);

        // 3) Build a compact model per service
        var serviceModels = services.Select(static (t, _) =>
        {
            var (impl, attr) = t;

            // Lifetime (positional arg 0)
            var lifetime = Lifetime.Scoped;
            if (attr!.ConstructorArguments.Length == 1 &&
                attr.ConstructorArguments[0].Value is int li)
                lifetime = (Lifetime)li;

            // Named arg: As (Type?)
            INamedTypeSymbol? asType = null;
            foreach (var na in attr.NamedArguments)
                if (na.Key == "As" && na.Value.Value is INamedTypeSymbol ts) { asType = ts; break; }

            // Named arg: AsSelf (bool)
            var asSelf = false;
            foreach (var na in attr.NamedArguments)
                if (na.Key == "AsSelf" && na.Value.Value is bool b) { asSelf = b; break; }

            // Skip abstract/ open-generic/ non-public impls
            if (impl!.IsAbstract || impl.Arity != 0 || impl.DeclaredAccessibility != Accessibility.Public)
                return (ServiceModel?)null;

            // If As not specified, infer: pick a single public interface (excluding IDisposable) if there is exactly one
            INamedTypeSymbol? inferred = null;
            if (asType is null)
            {
                var candidates = impl.AllInterfaces
                    .Where(i => i.DeclaredAccessibility == Accessibility.Public
                             && i.TypeKind == TypeKind.Interface
                             && i.Arity == 0
                             && i.ToDisplayString() != "System.IDisposable")
                    .ToArray();
                if (candidates.Length == 1) inferred = candidates[0];
            }

            var service = (asType ?? inferred);

            return new ServiceModel(
                Lifetime: lifetime,
                ImplFqn: impl.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ServiceFqn: service?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                AlsoAsSelf: asSelf
            );
        }).Where(static m => m is not null)!;

        // 4) Combine with Compilation and collect to one batch
        var combined = ctx.CompilationProvider.Combine(serviceModels.Collect());

        // 5) Emit single extension file
        ctx.RegisterSourceOutput(combined, static (spc, pair) =>
        {
            var (_, batch) = pair;
            var code = Emit(batch);
            spc.AddSource("GeneratedServiceCollectionExtensions.g.cs", code);
        });
    }

    private static string Emit(IReadOnlyList<ServiceModel> items)
    {
        // Deduplicate lines (in case of multi-targeted projects / partial classes, etc.)
        var seen = new HashSet<string>(StringComparer.Ordinal);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("public static class GeneratedServiceCollectionExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection AddGeneratedServices(this IServiceCollection s)");
        sb.AppendLine("    {");

        foreach (var m in items)
        {
            var method = m.Lifetime switch
            {
                Lifetime.Singleton => "AddSingleton",
                Lifetime.Scoped    => "AddScoped",
                Lifetime.Transient => "AddTransient",
                _ => "AddScoped"
            };

            // Register against interface if present; else self
            if (!string.IsNullOrEmpty(m.ServiceFqn))
            {
                var line = $"        s.{method}<{m.ServiceFqn}, {m.ImplFqn}>();";
                if (seen.Add(line)) sb.AppendLine(line);
                if (m.AlsoAsSelf)
                {
                    var self = $"        s.{method}<{m.ImplFqn}>();";
                    if (seen.Add(self)) sb.AppendLine(self);
                }
            }
            else
            {
                var self = $"        s.{method}<{m.ImplFqn}>();";
                if (seen.Add(self)) sb.AppendLine(self);
            }
        }

        sb.AppendLine("        return s;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed class ServiceModel
    {
        public ServiceModel(Lifetime Lifetime, string ImplFqn, string? ServiceFqn, bool AlsoAsSelf)
        {
            this.Lifetime = Lifetime;
            this.ImplFqn = ImplFqn;
            this.ServiceFqn = ServiceFqn;
            this.AlsoAsSelf = AlsoAsSelf;
        }
        public Lifetime Lifetime { get; }
        public string ImplFqn { get; }
        public string? ServiceFqn { get; }
        public bool AlsoAsSelf { get; }
    }

    // Mirror the annotations enum here so we can parse constructor args without referencing the annotations assembly at runtime.
    private enum Lifetime { Singleton = 0, Scoped = 1, Transient = 2 }
}
